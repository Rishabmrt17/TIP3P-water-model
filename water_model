import numpy as np

def run_md(N, size, T, step, delta_step, dt):
    """
    MD program using leap-frog algorithm for TIP3P modified  water model
    N = number_of_water_molecules
    size = size_of_the_box
    T = temperature
    step = number_of_steps
    delta_step = frequency_in_steps
    dt = time_step
    """
    kB = 0.00198 # kcal/mol/K
    # Define particle masses and charges
    m_oxygen = 15.9994  # Oxygen mass (amu)
    m_hydrogen = 1.008  # Hydrogen mass (amu)
    m = 17.0074 # mass of water (amu)
    q_oxygen = -0.834  # Oxygen charge (e)
    q_hydrogen = 0.417  # Hydrogen charge (e)

    # Define harmonic bond constants
    kbond = 450 #kcal/mole/â„«**2
    req = 0.9572 #Angstrom
    k_angle = 55.0 #kcal/mol/rad-2
    theta_eq = 1.82 #radian

    # Define Lennard-Jones parameters for oxygen-oxygen interaction
    #sigma_oo = 3.1506  # Angstrom
    #eps_oo = 0.1521  # kcal/mol

    # Define Lennard-Jones parameters for oxygen-hydrogen interaction
    sigma_oh = 1.0  # Angstrom
    eps_oh = 0.0  # kcal/mol

    # Define Lennard-Jones parameters for hydrogen-hydrogen interaction
    sigma_hh = 1.0 # Angstrom
    eps_hh = 0.0 # kcal/mol

    # Open trajectory file
    file = open("traj_MD.xyz", 'w')
    vel_file = open("vel_MD.xyz", 'w')
    force_file = open("force_MD.xyz", 'w')
    # Initialize positions
    positions = initialize_positions(N, size)
    # Initialize velocities
    velocities = initialize_velocities(N, kB, T, m)
    # Main MD loop
    for steps in range(step):

        # Initialize forces array
        forces = np.zeros_like(positions)

        # Compute Bonded Forces and Energy
        bonded_energy, bonded_force = compute_bonded_forces_energy(positions, kbond, req, size, forces)

        # Compute bond angle energy and forces
        angle_energy, bond_angle_force = compute_bond_angle_forces_energy(positions, k_angle, theta_eq, forces)

        # Compute Non-bonded Forces and Energy
        total_lj_energy, total_coulomb_energy, lj_force, coulomb_force = compute_lj_coulombic_energy_forces(positions, sigma_hh, eps_hh, sigma_oh, eps_oh, q_oxygen, q_hydrogen, size, forces)

        # Compute Total Forces
        totforce = tot_force(positions, bonded_force, lj_force, coulomb_force, bond_angle_force)

        #Compute Total Energy
        totEnergy = tot_energy(velocities, m, bonded_energy, total_lj_energy, total_coulomb_energy, angle_energy)

        # Propagate Positions and Velocities
        positions, velocities = leap_frog(positions, velocities, m, forces, dt, size)

        if steps % delta_step == 0:
            write_trajectory_frame(positions, file, step)
            write_trajectory_frame(velocities, vel_file, step)
            write_trajectory_frame(forces, force_file, step)
    # Close trajectory file
    file.close()
    vel_file.close()
    force_file.close()


######Sub-Routines########

# Initialize positions for TIP3P modified water model
def initialize_positions(N, size):
    """
    Initialize positions for TIP3P modified water model
    """
    bond_length_OH = 0.9572  # Oxygen-Hydrogen bond length (Angstrom)
    bond_angle_HOH = 1.82  # Oxygen-Hydrogen-Oxygen bond angle (degrees)

    positions = np.zeros((N * 3, 3))  # Initialize with shape (N * 3, 3)

    for i in range(N):
        oxygen_position = np.array([0.0, 0.0, 0.0])
        hydrogen_position1 = np.array([bond_length_OH, 0.0, 0.0])
        hydrogen_position2 = np.array([bond_length_OH * np.cos(np.radians(bond_angle_HOH)), bond_length_OH * np.sin(np.radians(bond_angle_HOH)), 0.0])

        # Assign calculated positions to the corresponding indices in the 'positions' array
        positions[i * 3] = oxygen_position
        positions[i * 3 + 1] = hydrogen_position1
        positions[i * 3 + 2] = hydrogen_position2

    print(positions)
    return positions

# Initialize velocities for TIP3P modified water model
def initialize_velocities(N, kB, T, m):
    """
    Initialize velocities for TIP3P modified water model
    kB = boltzmann_constant
    m = mass_of_water
    """
    velocities = np.random.normal(loc=0, scale=1, size=(N * 3, 3)) * np.sqrt(kB * T / m)
    print(velocities)
    return velocities

def compute_separation_vector_pbc_h2o(oxygen_position, hydrogen1_position, hydrogen2_position, size):
    """
    Compute separation vector considering periodic boundary conditions for a water molecule (H2O)
    oxygen_position   -   position of oxygen atom
    hydrogen1_position -   position of first hydrogen atom
    hydrogen2_position -   position of second hydrogen atom
    size              -   linear box dimension
    """

    dim = oxygen_position.shape[0]

    # Calculate separation vectors between oxygen and hydrogen atoms
    separation_vector_oh1 = oxygen_position - hydrogen1_position
    separation_vector_oh2 = oxygen_position - hydrogen2_position

    # Apply PBC for each separation vector
    for i in range(dim):
        if separation_vector_oh1[i] > 0.5 * size:
            separation_vector_oh1[i] -= size
        elif separation_vector_oh1[i] < -0.5 * size:
            separation_vector_oh1[i] += size

        if separation_vector_oh2[i] > 0.5 * size:
            separation_vector_oh2[i] -= size
        elif separation_vector_oh2[i] < -0.5 * size:
            separation_vector_oh2[i] += size

    return separation_vector_oh1, separation_vector_oh2

def compute_bonded_forces_energy(positions, kbond, req, size, forces):
    """
    Compute bonded forces and energy for TIP3P modified water model
    kbond = bond force constant
    req = equilibrium bond distance
    """
    # retrieve meta data
    N = positions.shape[0]
    # Initialize bonded energy
    bonded_energy = 0
    # declare the zeroed force array
    bonded_force = np.zeros((N,3))
    # Loop over water molecules
    for i in range(0, N, 3):
        # Calculate separation vectors between oxygen and hydrogen atoms
        separation_vector_oh1, separation_vector_oh2 = compute_separation_vector_pbc_h2o(positions[i], positions[i + 1], positions[i + 2], size)

        # Calculate bond lengths
        bond_length_oh1 = np.linalg.norm(separation_vector_oh1)
        bond_length_oh2 = np.linalg.norm(separation_vector_oh2)


        # Calculate harmonic bond potential energy
        bond_energy_oh1 = 0.5 * kbond * (bond_length_oh1 - req) ** 2
        bond_energy_oh2 = 0.5 * kbond * (bond_length_oh2 - req) ** 2

        # Accumulate the bonded energy
        bonded_energy += bond_energy_oh1 + bond_energy_oh2

        # Calculate derivative of bond energy with respect to bond length (bond force)
        bond_force_oh1 = -kbond * (bond_length_oh1 - req)
        bond_force_oh2 = -kbond * (bond_length_oh2 - req)

        # Accumulate the forces in the provided force array

        forces[i + 1] += bond_force_oh1
        forces[i + 2] += bond_force_oh2
        bonded_force += bond_force_oh1 + bond_force_oh2

    #print(bonded_energy, bonded_force)
    return(bonded_energy, bonded_force)

def compute_bond_angle_forces_energy(positions, k_angle, theta_eq, forces):
    """
    Compute bond angle forces and energy for TIP3P modified water model
    k_angle = angle force constant
    theta_eq = equilibrium bond angle
    """
    # Retrieve meta data
    N = positions.shape[0]
    # Initialize bonded angle energy
    angle_energy = 0
    # declare zeroed force array
    bond_angle_force = np.zeros((N,3))
    # Loop over water molecules
    for i in range(0, N, 3):
        # Calculate bond vectors
        bond_vector1 = positions[i + 1] - positions[i]
        bond_vector2 = positions[i + 1] - positions[i + 2]
        # Calculate bond angles
        cos_theta = np.dot(bond_vector1, bond_vector2) / (np.linalg.norm(bond_vector1) * np.linalg.norm(bond_vector2))
        theta = np.arccos(cos_theta)
        #print(theta)
        # Calculate harmonic angle potential energy
        angle_energy += 0.5 * k_angle * (theta - theta_eq) ** 2

        # Calculate forces based on angle deviation
        angle_force = -k_angle * (theta - theta_eq)

        # Accumulate the forces in the provided array
        bond_angle_force[i] += angle_force * bond_vector1 / np.linalg.norm(bond_vector1)
        bond_angle_force[i + 1] += angle_force * (bond_vector2 - bond_vector1) / np.linalg.norm(bond_vector2 - bond_vector1)
        bond_angle_force[i + 2] += angle_force * (-bond_vector2) / np.linalg.norm(bond_vector2)

    #print(angle_energy, bond_angle_force)
    return angle_energy, bond_angle_force

def compute_lj_coulombic_energy_forces(positions, sigma_hh, eps_hh, sigma_oh, eps_oh, q_oxygen, q_hydrogen, size, forces):
    """
    Compute non-bonded LJ and Coulombic force array
    """
    # retrieve meta data
    N = positions.shape[0]
    # Declare the zeroed force array
    lj_force = np.zeros((N, 3))
    coulomb_force = np.zeros((N,3))
    # Initialize non-bonded energy
    total_lj_energy = np.zeros((N,3))
    total_coulomb_energy = np.zeros((N,3))
    for i in range(0, N, 3):
        for j in range(i+1, N):
            # compute separation vector
            separation_vector = compute_separation_vector_pbc_h2o(positions[i], positions[i + 1], positions[i + 2], size)
            r = np.linalg.norm(separation_vector)

            # Select LJ and Coulomb parameters based on atom types
            epsilon = eps_hh if i % 3 == 0 and j % 3 == 0 else eps_oh
            sigma = sigma_hh if i % 3 == 0 and j % 3 == 0 else sigma_oh
            q_i = q_oxygen if i % 3 == 0 else q_hydrogen
            q_j = q_oxygen if j % 3 == 0 else q_hydrogen

            r6 = (sigma/r) ** 6
            r12 = r6 ** 2
            lj_energy = 4 * epsilon * (r12 - r6)
            coulomb_energy = (q_i * q_j) / (4 * np.pi * r)

            total_lj_energy += lj_energy
            total_coulomb_energy += coulomb_energy

            lj_force_factor = 24 * epsilon * (2 * r12 - r6) / (r ** 2)
            coulomb_force_factor = -(q_i * q_j) / (4 * np.pi * r ** 2)

            lj_force[i] += lj_force_factor
            lj_force[j] -= lj_force_factor
            coulomb_force[i] += coulomb_force_factor
            coulomb_force[j] -= coulomb_force_factor

    #print(total_lj_energy, total_coulomb_energy)
    print(lj_force, coulomb_force)
    return(total_lj_energy, total_coulomb_energy, lj_force, coulomb_force)


def tot_force(positions, bonded_force, lj_force, coulomb_force, bond_angle_force):
    """
    Total forces
    """
    total_force = np.zeros_like(positions)
    total_force += bonded_force + lj_force + coulomb_force + bond_angle_force
    #print(total_force)
    return(total_force)


def tot_energy(velocities, m, bonded_energy, total_lj_energy, total_coulomb_energy, angle_energy):
    v_sq = velocities ** 2
    v_sq_sum_d = np.sum(v_sq, axis = 1) # summing over dimension
    v_sq_sum_p = np.sum(v_sq_sum_d, axis=0) #summing over particles
    KE = 0.5 * m * v_sq_sum_p
    total_energy =  KE + bonded_energy + total_lj_energy + total_coulomb_energy + angle_energy
    #print(total_energy)
    return total_energy

def leap_frog(oxygen_position, hydrogen_position1, hydrogen_position2, oxygen_velocity, hydrogen_velocity1, hydrogen_velocity2, mass_oxygen, mass_hydrogen, dt, size):
    """
    oxygen_position = position of the oxygen atom
    hydrogen_position1 = position of the first hydrogen atom
    hydrogen_position2 = position of the second hydrogen atom
    forces = force_on_water_molecule
    m_oxygen = mass_of_oxygen
    m_hydrogen = mass_of_hydrogen
    dt = time_step
    size = size_of_box
    """
    # Update oxygen atom's velocity and position
    oxygen_velocity += (forces * dt / mass_oxygen)
    oxygen_position += oxygen_velocity * dt

    # Update hydrogen atoms' velocity and position
    hydrogen_velocity1 += (forces * dt / mass_hydrogen)
    hydrogen_velocity2 += (forces * dt / mass_hydrogen)
    hydrogen_position1 += hydrogen_velocity1 * dt
    hydrogen_position2 += hydrogen_velocity1 * dt

    # Wrap atom positions into the central box (box is from 0 to size in each dimension)
    positions = [oxygen_position, hydrogen_position1, hydrogen_position2]
    velocities = [oxygen_velocity, hydrogen_velocity1, hydrogen_velocity2]
   
    for i in range(3):
        for j in range(3):
            if positions[i][j] < 0:
                positions[i][j] += size
            elif positions[i][j] > size:
                positions[i][j] -= size
    return positions, velocities

# Trajectory frame
def write_trajectory_frame(positions, file_pointer, step):
    """
    positions = particle_positions
    file_pointer = trajectory_file_pointer
    step = step_number
    """
    N = positions.shape[0]
    file_pointer.write(" %8d\n"  % (N))
    file_pointer.write("frame: %8d\n" % (step))

    for i in range(N):
        atom_type = "O" if i == 0 else "H"
        file_pointer.write("%4s %10.5f %10.5f %10.5f\n" % (atom_type, positions[i, 0], positions[i, 1], positions[i, 2]))

# Run the simulation for TIP3P modified water model
N = 1  # Number of water molecules (3 particles each)
size = 10.0  # Angstrom
T = 300
step = 100000
delta_step = 100
dt = 0.0001
sim = run_md(N, size, T, step, delta_step, dt)
~                                                             
